<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF8">
  <title>Widget usage diagram</title>
  <script type="text/javascript" src="bower_components/vis/dist/vis.js"></script>
  <link type="text/css" rel="stylesheet" href="bower_components/vis/dist/vis.css">

  <style type="text/css">
    #networkMap {
      /*width: 800px;*/
      height: 500px;
      border: 1px solid lightgray;
    }

    div.nodeContent {
      position: relative;
      border: 1px solid lightgray;
      width: 480px;
      height: 780px;
      margin-top: -802px;
      margin-left: 810px;
      padding: 10px;
    }

    pre {
      padding: 5px;
      margin: 5px;
    }

    .string {
      color: green;
    }

    .number {
      color: darkorange;
    }

    .boolean {
      color: blue;
    }

    .null {
      color: magenta;
    }

    .key {
      color: red;
    }
  </style>
</head>

<body>

<h2>PT widget usage</h2>
<p>Notes about the chart:</p>
<ul>
  <li>If a session has less than 3 steps, NOOP state will be selected.</li>
  <li>If a session has more than 3 steps, the remaining ones are ignored.</li>
  <li>The final state is selected randomly.</li>
  <li>The actions have not been divided to consider the type of devices to avoid too many states.</li>
</ul>
<div id="networkMap"></div>

<script type="text/javascript">
  var network;

  var nodes = new vis.DataSet();
  var edges = new vis.DataSet();
  var gephiImported;

  var nodeContent = document.getElementById('nodeContent');

  var container = document.getElementById('networkMap');
  var data = {
    nodes: nodes,
    edges: edges
  };
  var options = {
    nodes: {
      shape: 'dot',
      font: {
        face: 'Tahoma'
      }
    },
    edges: {
      width: 0.15,
      smooth: {
        type: 'continuous'
      }
    },
    interaction: {
      dragNodes: false
    },
    physics:{
      enabled: false
    }
  };

  network = new vis.Network(container, data, options);


  //loadJSON('../datasources/WorldCup2014.json', redrawAll, function(err) {console.log('error')});
  loadJSON('data/edges.json', drawEdges, function(err) {console.log('Problem loading edges.')}, 3);
  drawStates(3);


  function loadJSON(path, success, error, numberOfLevels) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          success(JSON.parse(xhr.responseText), numberOfLevels);
        }
        else {
          error(xhr);
        }
      }
    };
    xhr.open('GET', path, true);
    xhr.send();
  }

  /**
   * This function fills the DataSets. These DataSets will update the network.
   */
  function redrawAll(gephiJSON) {
    if (gephiJSON.nodes === undefined) {
      gephiJSON = gephiImported;
    }
    else {
      gephiImported = gephiJSON;
    }

    nodes.clear();
    edges.clear();

    var fixed = fixedCheckbox.checked;
    var parseColor = parseColorCheckbox.checked;

    var parsed = vis.network.gephiParser.parseGephi(gephiJSON, {
      fixed: fixed,
      parseColor: parseColor
    });

    // add the parsed data to the DataSets.
    nodes.add(parsed.nodes);
    edges.add(parsed.edges);

    network.fit(); // zoom to fit
  }

  function getRandomColor() {
    var letters = '0123456789ABCDEF'.split('');
    var color = '#';
    for (var i = 0; i < 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }

  function drawStates(numberOfLevels) {
    var states = ['ADD', 'DEL', 'UPD', 'CONN', 'DISCONN', 'NOOP'];
    for (var i=1; i<=numberOfLevels; i++) {
      var color = getRandomColor();
      for (var j=0; j<states.length; j++) {
        nodes.add(
          {id: states[j] + String(i), label: states[j], color: color, x: 100*j, y: 100*i, size: 10}
        );
      }
    }
    nodes.add(
      {id: 'init', label: 'init', color: getRandomColor(), x: 100*(states.length-1)/2.0, y: 0, size: 10}
    );
    var color = getRandomColor();
    nodes.add([
      {id: 'pass', label: 'pass', color: color, x: 100*(states.length-1)/3.0, y: 100*(numberOfLevels+1), size: 10},
      {id: 'fail', label: 'fail', color: color, x: 200*(states.length-1)/3.0, y: 100*(numberOfLevels+1), size: 10},
    ]);
    network.fit(); // zoom to fit
  }

  function assert(condition, message) {
    if (!condition) {
        throw message || "Assertion failed";
    }
  }

  function drawEdges(actionsPerSessions, numberOfLevels) {
    var ret = [];
    for (var i=0; i<actionsPerSessions.length; i++) {
        // Levels + final state
        assert(actionsPerSessions[i].length==numberOfLevels+1, "The session has more states than expected.");
        var previousState = "init";
        for (var j=0; j<numberOfLevels+1; j++) {
          var currentState = actionsPerSessions[i][j]; // Levels + final state
          ret.push({"from": previousState, "to": currentState});
          previousState = currentState;
        }
    }
    edges.clear();
    edges.add(ret);
    network.fit(); // zoom to fit
  }

</script>


</body>
</html>

